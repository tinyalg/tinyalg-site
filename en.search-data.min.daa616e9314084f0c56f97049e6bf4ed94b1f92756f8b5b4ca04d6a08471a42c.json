[{"id":0,"href":"/docs/about-tinyalg/","title":"About Tinyalg","section":"Your Gateway to Embedded Tools and Insights","content":"\rAbout Tinyalg\r#\rTinyalg represents our dedication to enabling developers to explore the power of embedded systems and algorithms in innovative, accessible ways. Our mission is to create tools, resources, and insights that inspire creativity and problem-solving, no matter your level of expertise.\nWhat is Tinyalg?\r#\rTinyalg stands for \u0026ldquo;Tiny Algorithms,\u0026rdquo; reflecting our philosophy of maximizing impact through minimal, efficient, and elegant solutions. Whether you’re working with constrained embedded systems or exploring new design possibilities, Tinyalg is here to support your journey.\nWhy “Tiny”?\r#\rIn a world of ever-expanding complexity, “Tiny” emphasizes simplicity and precision. Our approach focuses on:\nEfficiency: Leveraging minimal resources for maximum output. Simplicity: Designing solutions that are easy to understand, use, and adapt. Scalability: Building tools that start small but can grow with your needs. #\rWe invite you to explore the Tinyalg Developer Hub and see how even the smallest ideas can lead to extraordinary outcomes.\n"},{"id":1,"href":"/docs/tyzr/developer-friendly-code/","title":"Why the Code is Developer-Friendly?","section":"Project: Tyzr","content":"\rWhy the Code is Developer-Friendly?\r#\rSix Reasons Why Tyzr Code Stands Out for Developers\r#\rThe Tyzr codebase is designed with clarity and simplicity in mind, making it approachable for developers of varying skill levels. Here\u0026rsquo;s why it is developer-friendly:\n1. Clear Separation of Concerns\r#\rEach function is designed to handle a specific task, such as:\nupdateDisplay: Updates the timer display on the LCD. setupGpio: Configures GPIO pins for debug or peripheral control. handleEvents: Manages button interactions and phase transitions. This modular approach keeps the code organized and easier to follow.\n2. Logical Flow\r#\rThe entry point, app_main(), is the main function for ESP-IDF projects and provides a step-by-step setup process:\nPeripheral and GPIO initialization. Display and speaker configuration. Task creation for display updates. Event loop to handle user interactions and periodic tasks. The clear flow allows developers to quickly understand the overall structure and purpose of the program.\n3. Readable Style\r#\rThe code uses descriptive names for variables and functions, such as:\ntimerRunning: Tracks whether the timer is active. enterDeepSleep: Prepares the device for low-power sleep mode. displayUpdateTask: Task responsible for updating the LCD. These names make the intent of the code clear, even without detailed comments.\n4. Comments for Configuration\r#\rPreprocessor directives like #ifdef CONFIG_TYZR_USE_SPK_HAT make it easy to spot configurable sections:\nDevelopers can enable or disable features like speaker usage or debug GPIOs by changing configuration macros. The use of CONFIG_ prefixes aligns with ESP-IDF’s configuration system, enhancing familiarity for ESP32 developers. 5. Modular Design\r#\rTasks and callbacks are separated for better maintainability:\nThe onTimer callback handles periodic timer updates without interfering with the main event loop. The displayUpdateTask focuses solely on refreshing the LCD. This ensures that each part of the code is easier to test and modify independently.\n6. No Overly Complex Logic\r#\rThe code avoids unnecessary complexity, focusing on:\nStandard synchronization: Uses FreeRTOS semaphores to coordinate between tasks. Atomic operations: Ensures safe updates to shared variables like timerCount in a multi-tasking environment. These patterns are common and well-documented in embedded systems development, making them approachable for developers.\nFeatures You Might Find Interesting\r#\rWhile the code is straightforward, some features may stand out as particularly helpful or insightful for embedded developers:\n1. Atomic Operations\r#\rThe code uses atomic_load and atomic_store for thread-safe operations on shared variables like timerCount. This ensures reliable behavior in a multi-tasking environment and is an essential pattern for embedded applications.\n2. RTC Memory Usage\r#\rRTC memory allows the ESP32 to retain critical data during deep sleep cycles, making it ideal for low-power applications. For example, variables like timerCount and isWorkPhase persist across sleep-wake transitions, ensuring continuity.\n3. Semaphore Synchronization\r#\rUsing xSemaphoreGive and xSemaphoreTake to coordinate tasks ensures efficient communication between the timer and display update processes. This approach demonstrates how to use FreeRTOS synchronization primitives effectively.\nThese patterns—atomic operations, RTC memory, and semaphore synchronization—are essential for building robust and efficient embedded systems.\nSummary\r#\rThe Tyzr codebase demonstrates:\nClear and modular design. Practical use of FreeRTOS and ESP-IDF features. Intuitive patterns that balance simplicity with functionality. Ready to dive in? Explore the Tyzr codebase and see how you can extend it for your next embedded project!\n"},{"id":2,"href":"/docs/tyzr/","title":"Project: Tyzr","section":"Your Gateway to Embedded Tools and Insights","content":"\rTyzr: Move Your Legs, Fuel Your Focus!\r#\r#\rA: Why is moving so important?\nB: Because if you don’t, you’ll end up like the plugged-in humans in The Matrix—passive and stuck.\nWith Tyzr, put your extra M5Stack to good use—helping you stay focused, active, and productive.\nFeatures\r#\rPomodoro-inspired 25/5 timer: Work for 25 minutes, then take a 5-minute break. Encourages healthy habits: Stay active and boost circulation with gentle reminders. Compatible with M5Stack devices: Easy to set up on any M5Stack with a display. Hardware Required\r#\rAny M5Stack device with a display, buttons, and a buzzer or speaker. A PC and a USB cable for flashing. Installation\r#\rInstall the ESP-IDF.\nFollow the instructions in the Installation section of the ESP-IDF Getting Started guide. It\u0026rsquo;s highly recommended to complete the Build Your First Project section before proceeding. Clone this repository:\ngit clone https://github.com/tinyalg/tyzr.git Configure your device:\nidf.py menuconfig Review the Tyzr app config in menuconfig, and adjust settings if needed. Make sure to configure the GPIO number for one of your M5Stack\u0026rsquo;s buttons to use it as wakeup source. See the Example Configurations below for suggested settings. Build and flash the firmware:\nidf.py -p PORT flash monitor (Replace PORT with your device\u0026rsquo;s serial port.)\n(To exit the serial monitor, type Ctrl-].)\nQuick Start\r#\rStart the timer: Press BUTTON A to start the 25-minute work timer. Take a break: After 25 minutes, a gentle beep reminds you to move for 5 minutes. Stop the timer: Press BUTTON A again to stop the timer and turn off the display. Restart: Press BUTTON B to reset the timer and start immediately. Wake up: When the timer sleeps, press BUTTON B to wake it up. Example Configurations\r#\rSetting Default M5Stack Gray M5StickC Plus GPIO number used as wakeup source 39 37 (BUTTON C) 39 (BUTTON B) Use SPK HAT - - ✓ (If you have one) Screen Rotation 1 1 1 X Coordinate of the digits 0 25 50 Y Coordinate of the digits 0 70 30 Scaling factor of the digits 1 2 1 Troubleshooting\r#\rNo Sound from the Buzzer or Speaker\r#\rCause: Buzzer or speaker not properly connected or configured. Solution: Ensure the hardware connections are secure. If using SPK HAT, verify that it is enabled in menuconfig. The Timer Doesn\u0026rsquo;t Respond After Sleep\r#\rCause: Wakeup GPIO not configured or pressed incorrectly. Solution: Verify the GPIO number for the wakeup source in menuconfig and ensure it matches your M5Stack model. #\rEnjoy the balance of productivity and well-being with Tyzr!\n"},{"id":3,"href":"/docs/licenses/","title":"Licenses","section":"Your Gateway to Embedded Tools and Insights","content":"\rLicenses\r#\rTinyalg Systems projects are licensed under the following terms:\nDocumentation: CC BY-NC-ND 4.0\r#\rThe documentation on dev.tinyalg.be is licensed under Creative Commons Attribution-NonCommercial-NoDerivatives 4.0.\nYou may share it non-commercially without modifications, with proper attribution:\nDocumentation by Tinyalg Systems, licensed under CC BY-NC-ND 4.0. Source: https://dev.tinyalg.be. Learn more at the CC BY-NC-ND 4.0 License page.\nSoftware: BSD 3-Clause\r#\rAll software is licensed under the BSD 3-Clause License, allowing use, modification, and redistribution with attribution.\nCopyright (c) 2024 Tinyalg Systems. Licensed under the BSD 3-Clause License. See LICENSE in the project repository. Explore software licenses:\nTyzr "},{"id":4,"href":"/posts/launched-tinyalg-developer-hub/","title":"Launched Tinyalg Developer Hub","section":"Blog","content":"\rLaunched Tinyalg Developer Hub\r#\rWe’re thrilled to announce the launch of the Tinyalg Developer Hub! Over the past week, we’ve been busy building the site using a combination of GitHub Pages and AWS Lightsail, and we’re excited to share the details behind its construction.\nWhether you’re a seasoned developer or just starting to explore the world of embedded systems, the Tinyalg Developer Hub is here to support your journey. Our goal is to provide practical tools, insightful resources, and inspiration to help you create and innovate with confidence.\nMain Site: GitHub Pages\r#\rThe Tinyalg Developer Hub serves as the central resource for embedded systems developers, hosting our tools, insights, and documentation.\nHosting: The site is hosted on GitHub Pages, ensuring a reliable and cost-effective solution for our primary content. Content Creation: We used Hugo to generate the static site and chose the versatile Book theme for a clean and developer-friendly layout. Backend: AWS Lightsail\r#\rThe backend infrastructure is powered by AWS Lightsail, offering flexibility and simplicity for managing additional services.\nWeb Server: We use Nginx as the web server to host. Nginx was selected over alternatives like Apache because of its event-driven architecture, making it highly efficient for serving static files and handling concurrent connections with minimal resource usage. This makes it an ideal choice for our lightweight static website setup.\nAnalytics with Matomo:\nWe use Matomo to track page access and gather insights while respecting user privacy. By avoiding cookies, we ensure a distraction-free experience without intrusive consent popups. Static Website:\ntinyalg.be: A straightforward HTML site for our organization’s main entry point. #\rWe’re excited to see how developers engage with the Tinyalg Developer Hub. Whether you’re here to learn, experiment, or collaborate, we encourage you to explore the site and discover what it has to offer. Our GitHub repository is open for contributions and feedback—currently, we have Tyzr, with more to come! Join us to help shape the future of embedded systems development. Share your thoughts, bookmark our resources, and stay tuned for future updates—we’re just getting started!\n"},{"id":5,"href":"/docs/","title":"Your Gateway to Embedded Tools and Insights","section":"Your Gateway to Embedded Tools and Insights","content":"\rYour Gateway to Embedded Tools and Insights\r#\rNot sure where to start? Check the sidebar on the left for these topics:\nGetting Started with Tyzr If you can\u0026rsquo;t find what you\u0026rsquo;re looking for, stay tuned—new content is being added regularly!\n"}]