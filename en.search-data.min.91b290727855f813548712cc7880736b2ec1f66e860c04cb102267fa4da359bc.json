[{"id":0,"href":"/docs/tyzr/","title":"Tyzr","section":"Docs","content":"\rTyzr: Move Your Legs, Fuel Your Focus!\r#\r#\rA: Why is moving so important?\nB: Because if you don’t, you’ll end up like the plugged-in humans in The Matrix—passive and stuck.\nWith Tyzr, put your extra M5Stack to good use—helping you stay focused, active, and productive.\nFeatures\r#\rPomodoro-inspired 25/5 timer: Work for 25 minutes, then take a 5-minute break. Encourages healthy habits: Stay active and boost circulation with gentle reminders. Compatible with M5Stack devices: Easy to set up on any M5Stack with a display. Hardware Required\r#\rAny M5Stack device with a display, buttons, and a buzzer or speaker. A PC and a USB cable for flashing. Installation\r#\rInstall the ESP-IDF.\nFollow the instructions in the Installation section of the ESP-IDF Getting Started guide. It\u0026rsquo;s highly recommended to complete the Build Your First Project section before proceeding. Clone this repository:\ngit clone https://github.com/tinyalg/tyzr.git Configure your device:\nidf.py menuconfig Review the Tyzr app config in menuconfig, and adjust settings if needed. Make sure to configure the GPIO number for one of your M5Stack\u0026rsquo;s buttons to use it as wakeup source. See the Example Configurations below for suggested settings. Build and flash the firmware:\nidf.py -p PORT flash monitor (Replace PORT with your device\u0026rsquo;s serial port.)\n(To exit the serial monitor, type Ctrl-].)\nQuick Start\r#\rStart the timer: Press BUTTON A to start the 25-minute work timer. Take a break: After 25 minutes, a gentle beep reminds you to move for 5 minutes. Stop the timer: Press BUTTON A again to stop the timer and turn off the display. Restart: Press BUTTON B to reset the timer and start immediately. Wake up: When the timer sleeps, press BUTTON B to wake it up. Example Configurations\r#\rSetting Default M5Stack Gray M5StickC Plus GPIO number used as wakeup source 39 37 (BUTTON C) 39 (BUTTON B) Use SPK HAT - - ✓ (If you have one) Screen Rotation 1 1 1 X Coordinate of the digits 0 25 50 Y Coordinate of the digits 0 70 30 Scaling factor of the digits 1 2 1 Troubleshooting\r#\rNo Sound from the Buzzer or Speaker\r#\rCause: Buzzer or speaker not properly connected or configured. Solution: Ensure the hardware connections are secure. If using SPK HAT, verify that it is enabled in menuconfig. The Timer Doesn\u0026rsquo;t Respond After Sleep\r#\rCause: Wakeup GPIO not configured or pressed incorrectly. Solution: Verify the GPIO number for the wakeup source in menuconfig and ensure it matches your M5Stack model. #\rEnjoy the balance of productivity and well-being with Tyzr!\n"},{"id":1,"href":"/docs/tyzr/developer-friendly-code/","title":"Why the Code is Developer-Friendly?","section":"Tyzr","content":"\rWhy the Code is Developer-Friendly?\r#\rSix Reasons Why Tyzr Code Stands Out for Developers\r#\rThe Tyzr codebase is designed with clarity and simplicity in mind, making it approachable for developers of varying skill levels. Here\u0026rsquo;s why it is developer-friendly:\n1. Clear Separation of Concerns\r#\rEach function is designed to handle a specific task, such as:\nupdateDisplay: Updates the timer display on the LCD. setupGpio: Configures GPIO pins for debug or peripheral control. handleEvents: Manages button interactions and phase transitions. This modular approach keeps the code organized and easier to follow.\n2. Logical Flow\r#\rThe entry point, app_main(), is the main function for ESP-IDF projects and provides a step-by-step setup process:\nPeripheral and GPIO initialization. Display and speaker configuration. Task creation for display updates. Event loop to handle user interactions and periodic tasks. The clear flow allows developers to quickly understand the overall structure and purpose of the program.\n3. Readable Style\r#\rThe code uses descriptive names for variables and functions, such as:\ntimerRunning: Tracks whether the timer is active. enterDeepSleep: Prepares the device for low-power sleep mode. displayUpdateTask: Task responsible for updating the LCD. These names make the intent of the code clear, even without detailed comments.\n4. Comments for Configuration\r#\rPreprocessor directives like #ifdef CONFIG_TYZR_USE_SPK_HAT make it easy to spot configurable sections:\nDevelopers can enable or disable features like speaker usage or debug GPIOs by changing configuration macros. The use of CONFIG_ prefixes aligns with ESP-IDF’s configuration system, enhancing familiarity for ESP32 developers. 5. Modular Design\r#\rTasks and callbacks are separated for better maintainability:\nThe onTimer callback handles periodic timer updates without interfering with the main event loop. The displayUpdateTask focuses solely on refreshing the LCD. This ensures that each part of the code is easier to test and modify independently.\n6. No Overly Complex Logic\r#\rThe code avoids unnecessary complexity, focusing on:\nStandard synchronization: Uses FreeRTOS semaphores to coordinate between tasks. Atomic operations: Ensures safe updates to shared variables like timerCount in a multi-tasking environment. These patterns are common and well-documented in embedded systems development, making them approachable for developers.\nFeatures You Might Find Interesting\r#\rWhile the code is straightforward, some features may stand out as particularly helpful or insightful for embedded developers:\n1. Atomic Operations\r#\rThe code uses atomic_load and atomic_store for thread-safe operations on shared variables like timerCount. This ensures reliable behavior in a multi-tasking environment and is an essential pattern for embedded applications.\n2. RTC Memory Usage\r#\rRTC memory allows the ESP32 to retain critical data during deep sleep cycles, making it ideal for low-power applications. For example, variables like timerCount and isWorkPhase persist across sleep-wake transitions, ensuring continuity.\n3. Semaphore Synchronization\r#\rUsing xSemaphoreGive and xSemaphoreTake to coordinate tasks ensures efficient communication between the timer and display update processes. This approach demonstrates how to use FreeRTOS synchronization primitives effectively.\nThese patterns—atomic operations, RTC memory, and semaphore synchronization—are essential for building robust and efficient embedded systems.\nSummary\r#\rThe Tyzr codebase demonstrates:\nClear and modular design. Practical use of FreeRTOS and ESP-IDF features. Intuitive patterns that balance simplicity with functionality. Ready to dive in? Explore the Tyzr codebase and see how you can extend it for your next embedded project!\n"},{"id":2,"href":"/docs/licenses/","title":"Licenses","section":"Docs","content":"\rLicenses\r#\rTinyalg Systems projects are licensed under the following terms:\nDocumentation: CC BY-NC-ND 4.0\r#\rThe documentation on dev.tinyalg.be is licensed under Creative Commons Attribution-NonCommercial-NoDerivatives 4.0.\nYou may share it non-commercially without modifications, with proper attribution:\nDocumentation by Tinyalg Systems, licensed under CC BY-NC-ND 4.0. Source: https://dev.tinyalg.be. Learn more at the CC BY-NC-ND 4.0 License page.\nSoftware: BSD 3-Clause\r#\rAll software is licensed under the BSD 3-Clause License, allowing use, modification, and redistribution with attribution.\nCopyright (c) 2024 Tinyalg Systems. Licensed under the BSD 3-Clause License. See LICENSE in the project repository. Explore software licenses:\nTyzr "}]